---
title: 特权指令、访管指令、陷入指令、广义指令
date: 2020-01-18 20:38:31
tags:
 - CS
typora-root-url: ..
typora-copy-images-to: ..\img
---

对操作系统、计算机组成原理入门具有一定指导意义，对计算机考研知识理解具有一定辅助作用，对工作中的实际应用可能基本没用。

+ 特权指令

○ 从指令系统（指令集）角度定义，在指令系统中拥有用于管理硬件和整个系统安全的指令，让程序随意使用具有极高危险性。不得在用户态（目态）执行，只能在核心态（管态）执行，用户态程序如果运行特权指令将发生异常，并切换到管态由操作系统接管cpu。所以用户程序不得使用特权指令，需要执行特权指令需要使用防管指令，进入核心态。

 + 访管指令

○ 同样从指令集的角度定义，或者说从硬件角度（cpu状态）。防管指令，是用户程序自愿进管的指令（进管同时也意味着程序放弃cpu的控制权），该指令本身属于非特权指令，可在用户态执行，执行后进入核心态。核心态是通过cpu置相应标志表明当前处于核心态。cpu进入核心态后可以执行指令集中的所有指令（包括特权指令和非特权指令，但不执行访管指令）。

+ 陷入指令

○ 原则上可看作访管指令，但是从操作系统的角度定义的。访管强调的是cpu从用户态切换到了核心态，可以执行指令集中的所有指令。而陷入（自陷、陷阱）指令强调程序从用户程序从用户台切换到内核态(以下简称切换到操作系统)，陷入指令即汇编中的中断指令。执行陷入指令程序会中断，跳转到中断服务程序（操作系统的代码）。所以访管强调的是可以执行特权指令，陷入强调的是进程放弃cpu，交还给操作系统。其实核心态和操作系统是不可分割的：道理很显然，进入核心态（管态），必然需要“跳转”到操作系统，不然区分用户态和核心态就没有了意义，如果程序执行完访管指令后，只是进入了管态，之后仍然执行自身的代码，那用户程序将可以为所欲为，显然不能允许。另一方面，如果cpu跳转到了操作系统，没有进入管态，那操作系统也无法执行特权指令，不能管理整个机器，显然也不行（当然也存在操作系统一部分运行在用户态，一部分（即内核）运行在管态，此时操作系统获取cpu控制权后不一定是处于核心态）。所以管态就是运行操作系统(内核代码)，访管指令本质上就是一条陷入（中断）指令。

<!--more-->

+ 广义指令（系统调用）

○ 系统调用，从操作系统的角度定义的。指用户程序需要借助操作系统来完成的特定操作，通过陷入指令可以进行系统调用。系统调用是一段代码而不是一条代码，在高级语言层面可能表现为一条，比如c语言的系统调用write()，在汇编层面这条语句包括，初始化相关参数和寄存器，执行陷入（中断）指令，跳转到中断服务程序执行，中断返回。之所以需要系统调用是因为用户程序不能执行特权指令，所以当需要完成特权指令才能做的特定操作，必须通过系统调用由操作系统完成。但系统调用一词并非强调程序不能使用特权指令，即不强调“需要”操作系统服务，仅仅强调“希望”让操作系统服务，表达的含义不是"不能"而是"不需要"，即目标操作用户程序不需要自己做，直接调用操作系统即可完成，进行系统调用时也并非一定为了执行特权指令，也可能相关操作过于复杂，或者用户程序自身难以实现（有权做但做起来麻烦），而操作系统刚好给出了相应的接口供直接使用。

+ 库函数

○ 操作系统提供的函数，供用户程序直接调用，简化程序的编写。编程时调用库函数直接使用操作系统已经实现的功能即可。与系统调用有些相似，不过库函数调用可以在用户态执行(不需要执行特权指令时)，和普通的函数调用应该并没有什么区别。无需用户态切换到核心态，执行中断服务程序等一些操作。是对系统调用“不需要做”这一概念的推广，另外现在一般用户不直接使用系统调用，而是使用封装好的库函数，由库函数进行系统调用。库函数的意义在于，需要就拿去用，不用再浪费时间了，直接拿大佬已经实现好的来搞。

+ 系统调用和函数调用的区别

○ 系统调用本质上应该也是一种函数调用，只是调用该函数是通过中断方式，INT 指令，进入核心态才能运行。

○ 函数调用通过CALL指令来进行，功能和JMP类似，只是JMP用于跳转指令，而CALL用于调用函数，指令跳转的同时要保存函数调用前下条指令的地址，以保证函数调用完能返回当前指令接着运行。本质上都是修改PC（程序计数器）的值，将下一条指令地址修改成相应指令地址。

○ 而系统调用是通过中断方式，即软件中断/陷入指令INT，执行后通过硬件关中断 保存断点和程序状态字 形成中断服务程序入口地址，之后执行中断服务程序。看起来很像是函数调用，只是系统调用会进入核心态，执行操作系统的代码。

○ 8086汇编语言函数返回

如果是段内调用，使用RET指令返回，从栈中弹出一个字，即IP(指令指针寄存器)

如果是段间调用，使用RETF指令返回，从栈中弹出两个字，即CS（代码段基址寄存器） 和IP

如果是系统调用，使用IREF指令返回，从栈中弹出三个字，即IP CS PSW（程序状态字）